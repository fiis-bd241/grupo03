# Objectos de Base de Datos

## Gestión de Pedidos

### Vista

Se tiene una vista llamada Todo_Pedido que permite visualizar todos los atributos relacionados con la tabla Pedido. Esta vista es útil porque la consulta se utiliza frecuentemente en el módulo, tanto de forma independiente o con cláusulas WHERE adicionales. Además, facilita la escritura del código al simplificar las consultas, ya que la consulta original contiene varios JOINS.

```sql
CREATE VIEW Todo_Pedido AS
	 SELECT 
		p."Pedido_Id" AS "Pedido",
		a."Area_Nombre" AS "Área Solicitante",
		s."nombre_squad" AS "Squad Encargardo",
		e."Estado_Tipo" AS "Estado",
		pr."Prioridad_Tipo" AS "Prioridad",
		p."Pedido_Fecha" AS "Fecha del Pedido", 
		p."Pedido_FechaLimite" AS "Fecha Límite"
	FROM public."Pedido" p
	INNER JOIN public."Area" a ON a."Area_Id" = p."Area_Id"
	INNER JOIN public."Squad" s ON s.id_squad = p."Id_Squad"
	INNER JOIN public."Estado" e ON e."Estado_Id" = p."Estado_Id"
	INNER JOIN public."Prioridad" pr ON p."Prioridad_Id" = p."Prioridad_Id"
	ORDER BY p."Pedido_FechaLimite" DESC;
```

### Índice

Para optimizar el rendimiento de la consulta de la tabla Pedido basándose en un rango de fechas, se realiza un análisis del plan de ejecución con el comando EXPLAIN ANALYZE. El código es el siguiente:

```sql
EXPLAIN ANALYZE
SELECT * FROM public."Pedido"
WHERE "Pedido_FechaLimite" BETWEEN '2022-02-1' AND '2024-06-25';
```

Primero, se ejecuta la  consulta con EXPLAIN ANALYZE sin índice, lo que cual nos da lo siguiente:

<div>
<img src=".\resources\GP-Analice-ConIndice.jpeg" alt="Sin Indice" style="width: auto; height: auto;"/>
</div>


Luego, de crea el siguiente el indice para Pedido_FechaLimite:

```sql
CREATE INDEX IX_P_FL ON public."Pedido"("Pedido_FechaLimite");
```

Ahora, se ejecuta la  consulta con EXPLAIN ANALYZE con el índice, lo que resulta en que:

<div>
<img src=".\resources\GP-Analice-SinIndice.jpeg" alt="Con Indice" style="width: auto; height: auto;"/>
</div>

Observamos que en ambas consultas el costo total estimado es el mismo, pero también vemos que el tiempo de ejecución y de planeación es el menor cuando se utiliza un índice en la consulta. Que el costo total sea igual en ambas consultas se debe a que los datos que tenemos en la tabla de pedidos son relativamente pocos.

### TRIGGER

Se crea el siguiente trigger para que se active automáticamente para actualizar la prioridad de un pedido antes de insertar un registro en la tabla Pedido. 

Primero, se crea una función que será llamada por el trigger. Esta función debe tomar los valores del registro que activó el trigger y luego actualizar los campos correspondientes. Al momento de insertar un nuevo pedido, al usuario se le pregunta si es importante. Si dice que es importante se coloca conmo prioridad alta ("Prioridad_Id" = 1) y si dice que no, se espera que la trigger complete según la diferencia fechas que hay hasta la fecha límte de la realización del pedido. 

```sql
CREATE OR REPLACE FUNCTION actualizarPrioridad() 
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
BEGIN
    IF (NEW."Pedido_FechaLimite" - NEW."Pedido_Fecha") < 7 
	THEN
        NEW."Prioridad_Id" = 1;
    ELSIF (NEW."Pedido_FechaLimite" - NEW."Pedido_Fecha") < 15 AND NEW."Prioridad_Id" <> 1 
	THEN
        NEW."Prioridad_Id" = 2;
    ELSIF NEW."Prioridad_Id" <> 1 
	THEN
        NEW."Prioridad_Id" = 3;
    END IF;
    RETURN NEW;
END;
$$;
```

Una vez específicada la lógica en la función, se crea en trigger para que se active antes de hacer una inserción.

```sql
CREATE TRIGGER trigger_actualizarPrioridad
BEFORE INSERT ON "Pedido"
FOR EACH ROW
EXECUTE FUNCTION actualizarPrioridad();
```


[Regresar al índice](Indice.md)
